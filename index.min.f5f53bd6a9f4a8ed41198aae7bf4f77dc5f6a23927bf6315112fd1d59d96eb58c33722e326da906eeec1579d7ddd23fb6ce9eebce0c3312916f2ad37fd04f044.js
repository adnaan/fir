var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/overview/introduction/",title:"Introduction",description:"The Fir toolkit offers a Go library, an Alpine.js plugin and a model-view generator CLI to build progressively enhanced reactive web interfaces with mostly server-rendered HTML.",content:`A Go toolkit to build reactive web interfaces.
Why does it exist ? # Wants to provide a way to build moderately complex reactive apps for folks who are comfortable with Go.
The library is a result of a series of experiments to build reactive apps in Go: gomodest-template. It works by patching the DOM on user events using morphdom.
What is it ? # Its a toolkit: a Go library, a CLI and an alpine.js plugin Focuses only on the view layer. Ships with an Alpinejs plugin for user interactions(click, submit, navigate ) etc. Who is it for ? # Suitable for Go developers who want to build moderately complex apps, internal tools, prototypes etc. Skills needed: Go, HTML, CSS, Alpine.js. What can you do with it ? # Build reactive webapps using Go, html/template and sprinkles of declarative javascript(alpine.js) Update parts of the web page on user interaction without reloading the page over regular http: clicks, form submits etc. Stream page updates over a persistent connection(WS, SSE): notifications, live tickers, chat messages etc. Use the CLI to generate html using entgo schema Is it like hotwire or is it like phoenix liveview ? # It borrows the idea of patching DOM on user interaction events from phoenix live view. But instead of streaming DOM diffs over websocket and sticthing it back on the client, it takes the hotwire approach of re-rendering html templates on the server and sending back a patch DOM operation to the javascript client over standard HTTP.
Live patching of the DOM(over websockets, sse) is also available but only for server driven DOM patching.(notifications, live ticker etc.)
Principles # Library and not a framework. It’s a Go library to build reactive user interfaces. Nothing crazy tech: It is built on nothing crazy tech: Go, html/template and Alpinejs. It’s just plain old html templates sprinkled with a bit of javascript. Keep Go code free of html/css: Use html/template to hydrate html pages. Keep Javascript to the minimum: Alpinejs provides declarative constructs to wire up moderately complex logic. The fir JS client provides additional Alpinejs functions and directives to achieve this goal. Have a simple lifecycle: Stages: Render html page -\u0026gt; Handle UI change events → Update parts of the html. Be SEO friendly: First page render is done fully on the server side. Real-time interaction is done once the page has been rendered. Have a low learning curve: For a Go user the only new thing to learn would be Alpinejs. And yes: HTML \u0026amp; CSS No custom template engine: Writing our own template engine can enable in-memory html diffing and minimal change partial for the client, but it also means maintaining a new non standard template engine. Status # Work in progress. The current focus is to get to a developer experience which is acceptable to the community. Roadmap to v1.0.0 is still uncertain.
`}),e.add({id:1,href:"/docs/overview/",title:"Overview",description:"Overview docs.",content:""}),e.add({id:2,href:"/docs/tutorials/",title:"Tutorials",description:"Tutorial docs.",content:""}),e.add({id:3,href:"/docs/tutorials/quick-start/",title:"Quick Start",description:"A quick start for the Fir toolkit",content:"Lets spend the next 15 minutes creating a simple app. If you want to skip ahead and look at final code, its here: examples/tasks/main.go\nPrerequisites # Have you installed Go 1.18 ? If yes, we are good to go.\nCreating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;fir.DefaultView{})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } mkdir hello-fir \u0026amp;\u0026amp; cd hello-fir touch main.go # copy-paste the above snippet go get ./... go run main.go Open localhost:9867 to see the running app.\nWe have created a controller and registered a DefaultView by calling controller.Handler(\u0026amp;fir.HelloView{}). The contoller.Handler method accepts a View interface. fir.DefaultView satisfies the methods for the View interface with default values.\nThe fir library doesn\u0026rsquo;t manage routing so you can bring your favorite routing library to actually route requests to the view. Here we keep it simple and mount the http.HandlerFunc returned by controller.Handler on the / route: http.Handle(\u0026quot;/\u0026quot;, c.Handler(\u0026amp;fir.DefaultView{}))\nCreating a new view # Lets start rendering a simple html page. To do this we want to create a new view and replace DefaultView.\nThis is how we do that:\ntype TaskView struct { fir.DefaultView } func (*TaskView) Content() string { return \u0026quot;A tasks app\u0026quot; } In the above snippet we have created a new struct, TaskView and embedded a fir.DefaultView type in it to satisfy the View interface.\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (*TaskView) Content() string { return \u0026quot;A tasks app\u0026quot; } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above code to see the changes at localhost:9867.\nRender Page # A Page in fir is a full web page which is rendered when a route is loaded. The View interface exposes two methods to render pages: OnGet and OnPost. OnGet is called when the page is loaded with a http GET request. We override OnGet to supply data to html/template renderer. OnPost can be overriden to handle form submissions from the browser. Both of these methods reload and re-render the full page.\npackage main import ( \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (t *TaskView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { t.RLock() defer t.RUnlock() return fir.Page{Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnPost(_ http.ResponseWriter, r *http.Request) fir.Page { t.Lock() defer t.Unlock() var task Task if err := fir.DecodeForm(\u0026amp;task, r); err != nil { return fir.PageError(err, \u0026quot;failed to decode form\u0026quot;) } t.tasks = append(t.tasks, task) return fir.Page{Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}} } func (*TaskView) Content() string { return ` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt;` } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above update code. Go to localhost submit a new task.\nCreating a new task is handled by OnPost which appends a new task to tasks and then re-renders the Page with updated tasks.\nPatch Page # In the above example, we reload the entire page when a new task is created. Fir offers a way to re-render sections of a page without reloading the page. We call this a Patch operation. If we look at the html being rendered, we can see that only following snippet needs to be re-rendered instead of the whole page:\n{{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} Since we want to re-render this section of our html on the server, we will wrap it around in a defined template(html/template). We will use the block action.\nThe updated html snippet should look like this:\n{{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} The range action is wrapped in a \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; so that we can target that html section for re-rendering it. We now need a way to handle the form submission and respond with a Patch operation to update the changed section.\nEmit page events # Fir has a companion javascript library which lets you send browser events to the server. You can use these events to change server state(in our case: tasks []Task) and make partial page updates without a page reload. Lets include the fir javascript library in our html page by overriding the Layout method of the View interface. We have also updated the Content() method:\nA defined template named content({{define \u0026quot;content\u0026quot;}} ... {{end}}{%end%}) which can be replaced in the Layout html string. \u0026lt;div x-data\u0026gt; so that we can use alpinejs features within this div tag. func (*TaskView) Layout() string { return ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` } func (*TaskView) Content() string { return ` {{define \u0026quot;content\u0026quot;}} \u0026lt;div x-data\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.submit\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}}` } Now we can use alpinejs @submit.prevent binding to call a utility function from the library: $fir.submit.\n\u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.submit\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; In the above snippet, we use the custom Alpinejs magic function, $fir.submit to send an event to the server on form submission. Internally $fir.submit collects the form data and sends a post request to the controller. Shortly we will see how to handle this event to change state on the server, followed by updating tasks on the web page.\nHandle page events # To handle page events emitted by the fir client library, we override the OnEvent method of the View interface. In response to a page event, we want to send back a set of Patch operations which can modify targeted sections of the page.\n... func (t *TaskView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;new-task\u0026quot;: var task Task if err := event.DecodeFormParams(\u0026amp;task); err != nil { return fir.PatchError(err, \u0026quot;failed to decode task\u0026quot;) } t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) return fir.Patchset{ fir.Morph{ Selector: \u0026quot;#tasks\u0026quot;, Template: \u0026amp;fir.Template{ Name: \u0026quot;tasks\u0026quot;, Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}, }, }, } } return nil } Final # The big idea behind Fir is wrapping a div in a {{ template ...}} html/template action and then later patching it over standard HTTP on state change. Below is the final code:\npackage main import ( \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Task struct { Text string `json:\u0026quot;text\u0026quot; schema:\u0026quot;text\u0026quot;` } type TaskView struct { fir.DefaultView tasks []Task sync.RWMutex } func (t *TaskView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { t.RLock() defer t.RUnlock() return fir.Page{Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnPost(_ http.ResponseWriter, r *http.Request) fir.Page { t.Lock() defer t.Unlock() var task Task if err := fir.DecodeForm(\u0026amp;task, r); err != nil { return fir.PageError(err, \u0026quot;failed to decode form\u0026quot;) } t.tasks = append(t.tasks, task) return fir.Page{Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}} } func (t *TaskView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;new-task\u0026quot;: var task Task if err := event.DecodeFormParams(\u0026amp;task); err != nil { return fir.PatchError(err, \u0026quot;failed to decode task\u0026quot;) } t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) return fir.Patchset{ fir.Morph{ Selector: \u0026quot;#tasks\u0026quot;, Template: \u0026amp;fir.Template{ Name: \u0026quot;tasks\u0026quot;, Data: fir.Data{\u0026quot;tasks\u0026quot;: t.tasks}, }, }, } } return nil } func (*TaskView) Layout() string { return ` \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` } func (*TaskView) Content() string { return ` {{define \u0026quot;content\u0026quot;}} \u0026lt;div x-data\u0026gt; \u0026lt;h1\u0026gt;Tasks\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026quot;new-task\u0026quot; method=\u0026quot;post\u0026quot; @submit.prevent=\u0026quot;$fir.submit\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;text\u0026quot; placeholder=\u0026quot;New task\u0026quot; /\u0026gt; \u0026lt;/form\u0026gt; {{block \u0026quot;tasks\u0026quot; .}} \u0026lt;div id=\u0026quot;tasks\u0026quot;\u0026gt; {{range .tasks}} \u0026lt;div\u0026gt;{{.Text}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}} \u0026lt;/div\u0026gt; {{end}}` } func main() { controller := fir.NewController(\u0026quot;task_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;TaskView{tasks: make([]Task, 0)})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } "}),e.add({id:4,href:"/docs/tutorials/counter-app/",title:"Counter App",description:`Lets spend the next 15 minutes creating a new reactive counter app. If you want to skip ahead and look at final code, its here: examples/counter/main.go
Prerequisites # Have you installed Go ? If yes, we are good to go.
Creating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.`,content:`Lets spend the next 15 minutes creating a new reactive counter app. If you want to skip ahead and look at final code, its here: examples/counter/main.go
Prerequisites # Have you installed Go ? If yes, we are good to go.
Creating a new app # The fir library concerns itself with only the view controller so starting off is as easy as mounting a view on the fir controller:
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;fir.DefaultView{})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Copy the above snippet in a main.go file and run go run main.go. Open localhost:9867 to see the running app.
We have created a controller and registered a DefaultView by calling controller.Handler(\u0026amp;fir.HelloView{}). The contoller.Handler method accepts a View interface. fir.DefaultView satisfies the methods for the View interface with default values.
The fir library doesn\u0026rsquo;t manage routing so you can bring your favorite routing library to actually route requests to the view. Here we keep it simple and mount the http.HandlerFunc returned by controller.Handler on the / route: http.Handle(\u0026quot;/\u0026quot;, c.Handler(\u0026amp;fir.DefaultView{}))
Creating a new view # We want to build a counter app. To do this we want to create a new view and replace DefaultView.
This is how we do that:
type CounterView struct { fir.DefaultView count int32 } func (c *CounterView) Content() string { return \u0026quot;A counter app\u0026quot; } In the above snippet we have created a new struct, CounterView and embedded a fir.DefaultView type in it to satisfy the View interface.
package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } type CounterView struct { fir.DefaultView model *Counter } func (c *CounterView) Content() string { return \u0026quot;A counter app\u0026quot; } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above code to see the changes at localhost:9867.
User interaction # Fir has a companion javascript library which lets you send browser events to the server. You can use these events to change server state(in our case: model *Counter) and make partial page updates without a page reload.
\u0026lt;div\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; In the above snippet, we use the custom Alpinejs magic function, \$fir.emit to send an event to the server on a button click. Shortly we will see how to handle this event to change state on the server, followed by updating a count on the web page.
Render view # Before we go ahead, lets expand the above snippet to a full html page.
Expand html page \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The html page includes the fir JS library which helps you add tiny bits of interactivity to the page. The library is an Alpinejs plugin and ships with extra direcitives(x-* thingy) and magic functions(\$ thingy).
Let\u0026rsquo;s add the above html page to the Content method of our view. The Content method can return either a valid filename or html.
Expand main.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } type CounterView struct { fir.DefaultView } func (c *CounterView) Content() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Running the above code, show render two buttons but nothing else. We want to show an initial count on the page. To do this, we use Go\u0026rsquo;s html/template to hydrate some data into our page by overriding the OnGet method of the View interface.
func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) (fir.Page) { return fir.Status{Code: 200}, fir.Data{ \u0026quot;count\u0026quot;: c.Value(), } } By default, fir.Data was zero value. After overriding OnGet we are initialising it with a count value. The page is then passed through html/template and rendered. This is the standard way of rendering html templates in Go so this should be recongisable.
{{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} block is a html/template built-in shorthand for defining and using a template.
This :
{{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} is same as:
{{define \u0026quot;count\u0026quot;}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} {{ template \u0026quot;count\u0026quot;}} Update parts of the view # In response to user interaction we want to update a part of our web page to display a result. Fir allows you to patch targeteted areas of the DOM without a page reload. Lets see it in action.
\u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}} \u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt; {{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt; + \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; When the + button is clicked, an event inc is sent to the server which sends backs a patch instruction back to the page.
func morphCount(c int32) fir.Patch { return fir.Morph{ Selector: \u0026quot;#count\u0026quot;, Template: \u0026amp;fir.Template{ Name: \u0026quot;count\u0026quot;, Data: fir.Data{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { return morphCount(atomic.AddInt32(\u0026amp;c.count, 1)) } func (c *Counter) Dec() fir.Patch { return morphCount(atomic.AddInt32(\u0026amp;c.count, -1)) } ... func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: log.Printf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } fir.Morph is a patch which hydrates the new count value to the template count(i.e. {{block \u0026quot;count\u0026quot; .}}{%endraw%}) on the server and instructs the javascript client library to update(morph) the \u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;.
The updated main.go should now be fully working counter example.
Expand main.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;sync/atomic\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 } func morphCount(c int32) fir.Patch { return fir.Morph{ Selector: \u0026quot;#count\u0026quot;, Template: \u0026amp;fir.Template{ Name: \u0026quot;count\u0026quot;, Data: fir.Data{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { return morphCount(atomic.AddInt32(\u0026amp;c.count, 1)) } func (c *Counter) Dec() fir.Patch { return morphCount(atomic.AddInt32(\u0026amp;c.count, -1)) } func (c *Counter) Value() int32 { return atomic.LoadInt32(\u0026amp;c.count) } type CounterView struct { fir.DefaultView model *Counter } func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { return fir.Page{ Data: fir.Data{ \u0026quot;count\u0026quot;: c.model.Value(), }} } func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: log.Printf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } func (c *CounterView) Content() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{model: \u0026amp;Counter{}})) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } If you want to skip ahead and look at final code for the optionals, its here: examples/counter-ticker/main.go
Optional: Layouts # Right now are, our html page is one big blob. We might want to separate out the layout from the content for reusability. To do this we need to override the Layout method of the View interface.
type LayoutView struct { fir.DefaultView } func (l *LayoutView) Content() string { return \`{{define \u0026quot;content\u0026quot;}}\u0026lt;div\u0026gt;world\u0026lt;/div\u0026gt;{{ end }}\` } func (l *LayoutView) Layout() string { return \`\u0026lt;div\u0026gt;Hello: {{template \u0026quot;content\u0026quot; .}}\u0026lt;/div\u0026gt;\` } Notice the {{template \u0026quot;content\u0026quot; .}}. Fir looks for an equivalent defined template in Content which here is: {{define \u0026quot;content\u0026quot;}}\u0026lt;div\u0026gt;world\u0026lt;/div\u0026gt;{{ end }}. By default it looks for a template named content but this can be overriden by returned a different layout name in LayoutContentName() string
Optional: Live Ticker # On user interaction events, OnEvent sends back a patchset which patches the interesting parts of the page. It would be nice to update the page when something changes for a user on the server(e.g. notifications, stock ticker, chat message etc.). Using the fir library its possible to stream a patch over websockets or server-sent events(SSE).
Override the Stream method of the View interface to return a receive only channel(\u0026lt;- chan Patch). When a patch is sent to this channel its sent to the client library where its executed to update the page.
type CounterView struct { fir.DefaultView model *Counter stream chan fir.Patch sync.RWMutex } func (c *CounterView) Stream() \u0026lt;-chan fir.Patch { return c.stream } ... http.Handle(\u0026quot;/\u0026quot;, controller.Handler(\u0026amp;CounterView{stream: make(chan fir.Patch)})) We can send a patch to the stream.
c.stream \u0026lt;- fir.Morph{...} Lets expand the counter example to add a last updated ticker to the page. The ticker should update every second and tell us when was count last updated.
For this example, we use a different patch type: fir.Store{}.
func NewCounterView() *CounterView { stream := make(chan fir.Patch) ticker := time.NewTicker(time.Second) c := \u0026amp;CounterView{stream: stream, model: \u0026amp;Counter{}} go func() { for ; true; \u0026lt;-ticker.C { patch, err := c.model.Updated() if err != nil { continue } stream \u0026lt;- patch } }() return c } \u0026lt;div\u0026gt;Count updated: \u0026lt;span x-text=\u0026quot;\$store.fir.count_updated || 0\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; seconds ago\u0026lt;/div\u0026gt; fir.Store{} updates the global alpinejs \$store. Since its reactive, the above html snippet automatically updates.
See the complete working example:
Expand main.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/adnaan/fir\u0026quot; ) type Counter struct { count int32 updated time.Time sync.RWMutex } func morphCount(c int32) fir.Patch { return fir.Morph{ Selector: \u0026quot;#count\u0026quot;, Template: \u0026amp;fir.Template{ Name: \u0026quot;count\u0026quot;, Data: fir.Data{\u0026quot;count\u0026quot;: c}, }, } } func (c *Counter) Inc() fir.Patch { c.Lock() defer c.Unlock() c.count += 1 c.updated = time.Now() return morphCount(c.count) } func (c *Counter) Dec() fir.Patch { c.Lock() defer c.Unlock() c.count -= 1 c.updated = time.Now() return morphCount(c.count) } func (c *Counter) Updated() (fir.Patch, error) { c.RLock() defer c.RUnlock() if c.updated.IsZero() { return nil, fmt.Errorf(\u0026quot;time is zero\u0026quot;) } return fir.Store{ Name: \u0026quot;fir\u0026quot;, Data: fir.Data{ \u0026quot;count_updated\u0026quot;: time.Since(c.updated).Seconds(), }, }, nil } func (c *Counter) Count() int32 { c.RLock() defer c.RUnlock() return c.count } func NewCounterView() *CounterView { stream := make(chan fir.Patch) ticker := time.NewTicker(time.Second) c := \u0026amp;CounterView{stream: stream, model: \u0026amp;Counter{}} go func() { for ; true; \u0026lt;-ticker.C { patch, err := c.model.Updated() if err != nil { continue } stream \u0026lt;- patch } }() return c } type CounterView struct { fir.DefaultView model *Counter stream chan fir.Patch sync.RWMutex } func (c *CounterView) Stream() \u0026lt;-chan fir.Patch { return c.stream } func (c *CounterView) Content() string { return \` {{define \u0026quot;content\u0026quot; }} \u0026lt;div class=\u0026quot;my-6\u0026quot; style=\u0026quot;height: 500px\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;columns is-mobile is-centered is-vcentered\u0026quot;\u0026gt; \u0026lt;div x-data class=\u0026quot;column is-one-third-desktop has-text-centered is-narrow\u0026quot;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;Count updated: \u0026lt;span x-text=\u0026quot;\$store.fir.count_updated || 0\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; seconds ago\u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; {{block \u0026quot;count\u0026quot; .}}\u0026lt;div id=\u0026quot;count\u0026quot;\u0026gt;{{.count}}\u0026lt;/div\u0026gt;{{end}} \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('inc')\u0026quot;\u0026gt;+ \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button has-background-primary\u0026quot; @click=\u0026quot;\$fir.emit('dec')\u0026quot;\u0026gt;- \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{end}}\` } func (c *CounterView) Layout() string { return \`\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{.app_name}}\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;A counter app\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css\u0026quot; /\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/@adnaanx/fir@latest/dist/fir.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{template \u0026quot;content\u0026quot; .}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\` } func (c *CounterView) OnGet(_ http.ResponseWriter, _ *http.Request) fir.Page { return fir.Page{ Data: fir.Data{ \u0026quot;count\u0026quot;: c.model.Count(), }} } func (c *CounterView) OnEvent(event fir.Event) fir.Patchset { switch event.ID { case \u0026quot;inc\u0026quot;: return fir.Patchset{c.model.Inc()} case \u0026quot;dec\u0026quot;: return fir.Patchset{c.model.Dec()} default: log.Printf(\u0026quot;warning:handler not found for event =\u0026gt; \\n %+v\\n\u0026quot;, event) } return nil } func main() { controller := fir.NewController(\u0026quot;counter_app\u0026quot;, fir.DevelopmentMode(true)) http.Handle(\u0026quot;/\u0026quot;, controller.Handler(NewCounterView())) http.ListenAndServe(\u0026quot;:9867\u0026quot;, nil) } Run the above main.go and go to localhost:9867. Incrementing or decrementing the count should update the ticker.
`}),e.add({id:5,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()